#  The structue of the project should probably be overhauled if you want it to installable with pip or "python setup.py install".  Usually the top level directory would contain things like setup.py, makefile, requirements.txt, etc and there will be a directory named hmk (or the like) containing your project.  "setup.py install" will build an egg file and place it in your virtualenv.

# Relative imports (e.g. "from .some_module import some_thing") are going cause you a lot of headaches.  I can see that you are already in a bit of import hell trying to import everything from the right place.  Try to organize your modules so that (if at all possible) you never have to import from a module at the same or higher hierarchy level. The risk of recursive imports (sort of like an import deadlock) is high unless you really know what you are doing.

#  You should have a requirements.txt file so that developers and users can install all python requirements into a virtualenv without needing to pip install the package.  This allows you to run the scripts for debugging without having to pip install/uninstall every time you make a change.  Additionally, a setup.py is only really necessary if you want to build a package that is "importable" for use in a separate project.

# Try not to do "from some_package import *".  Import the names that you need only.  This is a recipe for namespace conflicts, especially when you are using 3rd party libraries. If you are creating an importable package, then you greatly increase the chances of breaking the application that is using your library.

#  __init__.py files should really only be for creating import "shortcuts" of underlying modules.  So you can say "from POS import ItemButton" rather than "from POS.widgets.menu_display import ItemButton."  I've seen widely used python packages put implementation inside of __init__ files, but I think that's a bad idea unless you have good reason.

# If you need to have global constants, I'd get in the habit of creating constants.py files and putting them there rather than in lib/*.  If constants are only used by one class they should be class members (not instance members (i.e. self.something)).

# I'm seeing a lot of imports that don't get used.  Linting will help you clean this up.

# I'm not going to spend much time trying to figure why you are doing this, but the metaclasses are most certainly not the solution you are looking for.  Metaclasses are for creating class types.  My first guess is that you really just want multiple inheritance.

# I don't have a complete understanding of how all the pieces work together, but it seems like you are abusing the tuple type (e.g. inheriting from tuple, implementing new() to return a larger tuple).  What you likely want is to have some class composition (i.e. has-a relationship) to extend all the pieces that you are trying to aggregate.  When you want to put some data on the wire, then you would serialize the class members accordingly.

# This is more of an architectural suggestion about managing processes. main.main() either starts some multiprocessing.Process instances or issues a system console "kill" to them.  You may consider having main start as a management process.  In essence this process would be in charge of starting and stopping your subprocesses. It can stop the processes it manages with a multiprocessing.Event.  Then use a separate script to the command line args as commands.  That script will send messages to the management process to start/stop/restart the running processes.  (I hope all that is clear).  I dunno if the OS you are using is running systemd, but those multiprocessing.Process instances could be eliminated and implemented as systemd service units.  Then you could simplify your main.py to call "systemctl stop process1 process2 process3" when you want to kill everything.  Your processes that you want to control would just need to implement a SIGTERM signal handler to gracefully shutdown what they are doing.  What you have here is very simple, but systemd will automatically restart processes that crash (they will act like a service) and will simplify the task of starting/stopping them.
